library(pheatmap)
library(paletteer)
library(reshape)

# Funcion que calcula la copula inferior
W <- function(U){
  return(max(U[1]+U[2]-1, 0))
}

#Funcion que calcula la copula superior
M <- function(U){
  return(min(U[1], U[2]))
}

#Funcion para heatmap
D <- function(info){
  C <- info[1]; UIJ <- info[2]; M <- info[3]; W <- info[4]
  if (C >= UIJ){
    res <- (C -UIJ)/(M - UIJ)
  }else{
    res <- -(UIJ - C)/(UIJ - W)
  }
  return(res)
}


#Funcion que obtiene los heatmaps que se necesitan
#Para vizualizar copulas a pares

heats <- function(X, nombre, id, n = 100){
  #Variables para sacar la copulas empirica
  u <- seq(from = 0, to = 1, by = 1/(n-1))
  n <- length(u)
  #Matriz para hacer e grid
  matrizU <- data.frame(u1 = rep(0, n**2), u2 = rep(0, n**2))
  uj <- rep(0, n**2)

  #Hacemos en Grid
  cuenta <- 1
  for (i in 1:n){
    matrizU[cuenta:(i*n), 1] <- rep(u[i], n)
    matrizU[cuenta:(i*n), 2] <- u
    uj[cuenta:(i*n)] <- rep(u[i], n)*u

    cuenta <- cuenta + n
  }

  matrizU <- as.matrix(matrizU)

  #La copula empirica
  ec <- C.n(matrizU, X = X)

  #Hacemos las matrices
  ecF <- matrix(ec, ncol = n, nrow = n)
  UIJ <- matrix(uj, ncol = n, nrow = n)

  # Los heatmaps
  rho <- 12*(ecF - UIJ)
  sigma <- 12*abs(ecF - UIJ)

  breaksrho <- seq(-1, 1, by = 0.02)
  breaksigma <- seq(0, 1, by = 0.01)

  rho <- pheatmap(rho[nrow(rho):1,], breaks = breaksrho, border_color = NA,
           cluster_cols = FALSE,
           cluster_rows = FALSE, main = paste0('rho ', nombre))
  ggsave(rho, file = paste0(id, 'rho', nombre, '.png'), width = 4.5, height = 4)

  sigma <- pheatmap(sigma[nrow(sigma):1,], breaks = breaksigma, border_color = NA,
           color = rev(paletteer_c("grDevices::PuBuGn", 200)),
           cluster_cols = FALSE,
           cluster_rows = FALSE, main = paste0('Sigma ', nombre))
  ggsave(sigma, file = paste0(id, 'sigma', nombre, '.png'), width = 4.5, height = 4)

  #Heatmap de diferencias normalizadas
  info <- data.frame(copemp = ec, UVemp = uj,
                     Memp = apply(matrizU, MARGIN = 1, M),
                     Wemp = apply(matrizU, MARGIN = 1, W))

  H_melt <- data.frame(X1 = matrizU[,1], X2 = matrizU[,2],
                       value = apply(X = info, MARGIN = 1, FUN = D))

  #Corregimos algunos valores
  H_melt[is.infinite(H_melt$value), 3] <- sign(H_melt[is.infinite(H_melt$value), 3])*1
  H_melt[is.na(H_melt$value), 3] <- 0
  H_melt[abs(H_melt$value) > 1, 3] <- sign(H_melt[abs(H_melt$value) > 1, 3])*1

  heat <- ggplot(H_melt, aes(X1, X2)) + geom_tile(aes(fill = value))  +
    scale_fill_gradientn(colours = hcl.colors(100, palette = "spectral", rev = TRUE),
                         limits = c(-1, 1))

  H <- heat + geom_point(data = X, aes(x = X[,1], y = X[,2]),
                    color = "black", size = 1.5, alpha = 0.5) +
        ggtitle(paste('Diferencias Normalizadas ', nombre))
  ggsave(H, file = paste0(id, 'H', nombre, '.png'), width = 4.5, height = 4)
}

#Copulas para el nivel
cNivel <- function(nCopNivel, paraNivel, T = nNodos){
  cop <- c()
  secuencia <- rep(0, nCopNivel)

  if (paraNivel == 2){
    l <- 1; j <- 2
    for (i in secuencia) {
      cop <- c(cop, paste0('C', l, j))
      l <- l + 1; j <- j + 1
    }
  }else{
    for (i in 1:length(secuencia)){
      ind <- c(i:(i + (paraNivel-1)) )
      segundo <- paste(ind[2:(length(ind)-1)], collapse = '')
      primer <- paste0('C', ind[1], max(ind), '.', segundo)
      cop <- c(cop, primer)
    }
  }
  return(cop)
}

#Funcion que hace el graficos de Rvine
heatReg <- function(nodos, Udata, h_selection, id){

  for (nivel in 1:(nodos -1)){
    if (nivel == 1){
      #Nivel 1 -Copulas sencillas
      for (i in 1:(nodos-1)){
        heats(Udata[c(i, i+1)], nombre = paste0('C', i, i+1), id)
      }
    }else{
      if ((nodos-(nivel + 1)) >= 0){
        cops <- cNivel(nodos-nivel, nivel + 1, T = nNodos)

        #Para niveles profundos - Con h's
        for (copName in cops){
          i <- as.integer(substring(copName, 2, 2)); j <- as.integer(substring(copName, 3, 3))

          cond <- substring(copName, 5, nchar(copName))
          h1 <- paste0('h', i, '|', cond)
          h2 <- paste0('h', j, '|', cond)

          X <- data.frame(h1 = h_selection[[h1]],
                          h2 = h_selection[[h2]])

          heats(X, nombre = cops[i], id)
        }
      }
    }
  }
}

setwd('C:/Users/zaboo/OneDrive/Documentos/CIMAT/Tesis/codigo/Mio/4variables/heatmaps')
heatReg(5, Umujeres, h_selectM, 'Muj')
heatReg(5, Uhombres, h_selectH, 'Hom')
heatReg(5, Utotal, h_selectT, 'Total')
