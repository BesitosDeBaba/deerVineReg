#Funcion que estima las funciones h pero ya con las copulas ajustadas
#Recibe como argumento:
#datosU <- dataframe con las variables en escala U y ordenadas
#de acuerdo al orden de importancia
#Regresa: una lista de copulas

forwardPred <- function(datosU, copulas){
  nNodos <- ncol(datosU)
  
  #Ciclo que va sobre cada 'arbol'
  for (nivel in 1:(nNodos-1)){
    if (nivel == 1){
      #Obtenemos las funciones h para las Copulas de este nivel
      cond <- 2 
      cops <- cparaH(nNodos-1, 2)
      
      #Sacamos las h en orden las de las copulas 
      for (i in 1:(2*(nNodos-cond))){
        nomH <- nombreH(c(cond + (-1)^i, cond))
        h_selectPred[[nomH]] <<- BiCopHfunc2(datosU[, (cond + (-1)^i)], datosU[, cond], 
                                         copulas[[cops[i]]])
        if ((i %% 2) == 0) cond <- cond + 1
      }
      #Para niveles m치s profundos 
    }else{
      #Calculamos las h's correspondientes a este nivel
      if ((nNodos-(nivel + 2)) >= 0){
        cops <- cparaH(nNodos-nivel, nivel + 1, T = nNodos) 
        
        #Sacamos las h en orden las de las copulas 
        cond <- c(1:(1 + (nivel)+1) )
        
        for (i in 1:length(cops)){
          primer <- abs(max(cond*((-1)^i)))
          condicional <- cond[2:(length(cond)-1)]
          nomH <- nombreH(c(primer, condicional))
          
          #--- Sacamos las H anidadas
          
          #Obtemos los nombres de las h
          if (i %% 2 == 1){
            h1 <- nombreH(c(primer, condicional[1:(length(condicional)-1)]))
            h2 <- nombreH(c(condicional[length(condicional)], 
                            condicional[1:(length(condicional)-1)])) 
          }else{
            h1 <- nombreH(c(primer, condicional[2:length(condicional)]))
            h2 <- nombreH(c(condicional[1], 
                            condicional[2:length(condicional)]))
          }
          
          h_selectPred[[nomH]] <<- BiCopHfunc2(h_selectPred[[h1]],
                                           h_selectPred[[h2]], 
                                           copulas[[cops[i]]])
          if ((i %% 2) == 0) cond <- cond + 1
        }
      }
    }
  }
  return(h_selectPred)
}

#Funcion que se encarga de sacar las inversas de cada copula
#la propagaci칩n hacia atr치s. Recibe como argumento:
#datosU <- dataframe con las datos ordenados en su escala U
#alpha <- quantile que se quiere obenter
quantileRegPred <- function(datosUs, alpha, copulas){
  nNodosAr <- ncol(datosUs)
  alphas <- rep(alpha, nrow(datosUs))
  
  for (i in (1:(nNodosAr-1))){
    indCop <- c(1:nNodosAr)  
    #Regresamos para niveles condicionales
    
    #Seleccionamos la copulas y la funcion h que se requieren
    if (length(indCop) > 2){
      copula <- nombreC(c(min(indCop), max(indCop), indCop[2:(length(indCop) -1)]) )
      funH <- h_selectPred[[nombreH(c( max(indCop), indCop[2:(length(indCop) -1)]) )]]
      
      nNodosAr <- nNodosAr -1
    }else{
      copula <- nombreC(indCop) 
      funH <- datosUs[, 2]
    }
    
    #Aplicamos la inversa
    alphas <- BiCopHinv2(alphas, funH, copulas[[copula]])
  }
  return(alphas)
}


#Funcion que calcula los cuantiles o transforma los valores datos a 
#escala de acuerdo a las variables que forman la base original. Para seguir
#la misma distribuci칩n. 
#Recibe como argumento:
#datos - un data frame con los datos Orginales.
#obser - un dataframe con las nuevas observaciones
#Retorna ObserU - un dataframe con las observaciones en escala U
Uexternos <- function(datos, obser){
  variables <- names(obser)
  obserU <- obser
  count <- 1
  
  #Sacamos las F de acuerdo a la distribucion de cada variable
  for (i in variables){
    obserU[, count] <-  ecdf(datos[,i])(obser[,count])
    count <- count + 1
  }
  return(obserU)
}

#Funcion que hace la regresion de la variable obser, usando 
#las copulas generadas. Recive como argumento.
#datos - un data frame con todas las variables originales.
#observ - data frame con las observaciones que se les quiere hacer prediccion
#NOTA: Obser debe tener los mismos nombres que en las variables en escala U
regresionPred <- function(datos, obser, y_real, alpha, copulas){
  h_selectPred <<- list()
  dataU <- Uexternos(datos, obser)
  hs <- forwardPred(dataU, copulas)
  
  #Hacemos las predicciones
  regA1 <- quantileRegPred(dataU, alpha, copulas)
  yA1 <- quantile(y_real, regA1)
  
  return(yA1)
}



#Funcion que le mueve ligeramente para encontrar la Raiz
regresionSemaforo <- function(datos, obser, corte, y_real, alpha, copulas){
  h_selectPred <<- list()
  dataU <- Uexternos(datos, obser)
  hs <- forwardPred(dataU, copulas)
  
  #Hacemos las predicciones
  regA1 <- quantileRegPred(dataU, alpha, copulas)
  yA1 <- quantile(y_real, regA1)
  
  return(yA1-corte)
}

