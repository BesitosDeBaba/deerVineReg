rho <- pheatmap(rho[nrow(rho):1,], breaks = breaksrho, border_color = NA,
cluster_cols = FALSE,
cluster_rows = FALSE, main = paste0('rho ', nombre))
ggsave(rho, file = paste0(id, 'rho', nombre, '.png'), width = 4.5, height = 4)
sigma <- pheatmap(sigma[nrow(sigma):1,], breaks = breaksigma, border_color = NA,
color = rev(paletteer_c("grDevices::PuBuGn", 200)),
cluster_cols = FALSE,
cluster_rows = FALSE, main = paste0('Sigma ', nombre))
ggsave(sigma, file = paste0(id, 'sigma', nombre, '.png'), width = 4.5, height = 4)
#Heatmap de diferencias normalizadas
info <- data.frame(copemp = ec, UVemp = uj,
Memp = apply(matrizU, MARGIN = 1, M),
Wemp = apply(matrizU, MARGIN = 1, W))
H_melt <- data.frame(X1 = matrizU[,1], X2 = matrizU[,2],
value = apply(X = info, MARGIN = 1, FUN = D))
#Corregimos algunos valores
H_melt[is.infinite(H_melt$value), 3] <- sign(H_melt[is.infinite(H_melt$value), 3])*1
H_melt[is.na(H_melt$value), 3] <- 0
H_melt[abs(H_melt$value) > 1, 3] <- sign(H_melt[abs(H_melt$value) > 1, 3])*1
print(H_melt)
break
heat <- ggplot(H_melt, aes(X1, X2)) + geom_tile(aes(fill = value))  +
scale_fill_gradientn(colours = hcl.colors(100, palette = "spectral", rev = TRUE),
limits = c(-1, 1)) + ylim(1, 0)
H <- heat + geom_point(data = X, aes(x = X[,1], y = X[nrow(X):1,2]),
color = "black", size = 1.5, alpha = 0.5) +
ggtitle(paste('Diferencias Normalizadas ', nombre))
ggsave(H, file = paste0(id, 'H', nombre, '.png'), width = 4.5, height = 4)
}
heatReg(5, Uhombres, h_selectH, 'Hom')
heats <- function(X, nombre, id, n = 100){
#Variables para sacar la copulas empirica
u <- seq(from = 0, to = 1, by = 1/(n-1))
n <- length(u)
#Matriz para hacer e grid
matrizU <- data.frame(u1 = rep(0, n**2), u2 = rep(0, n**2))
uj <- rep(0, n**2)
#Hacemos en Grid
cuenta <- 1
for (i in 1:n){
matrizU[cuenta:(i*n), 1] <- rep(u[i], n)
matrizU[cuenta:(i*n), 2] <- u
uj[cuenta:(i*n)] <- rep(u[i], n)*u
cuenta <- cuenta + n
}
matrizU <- as.matrix(matrizU)
#La copula empirica
ec <- C.n(matrizU, X = X)
#Hacemos las matrices
ecF <- matrix(ec, ncol = n, nrow = n)
UIJ <- matrix(uj, ncol = n, nrow = n)
# Los heatmaps
rho <- 12*(ecF - UIJ)
sigma <- 12*abs(ecF - UIJ)
breaksrho <- seq(-1, 1, by = 0.02)
breaksigma <- seq(0, 1, by = 0.01)
rho <- pheatmap(rho[nrow(rho):1,], breaks = breaksrho, border_color = NA,
cluster_cols = FALSE,
cluster_rows = FALSE, main = paste0('rho ', nombre))
ggsave(rho, file = paste0(id, 'rho', nombre, '.png'), width = 4.5, height = 4)
sigma <- pheatmap(sigma[nrow(sigma):1,], breaks = breaksigma, border_color = NA,
color = rev(paletteer_c("grDevices::PuBuGn", 200)),
cluster_cols = FALSE,
cluster_rows = FALSE, main = paste0('Sigma ', nombre))
ggsave(sigma, file = paste0(id, 'sigma', nombre, '.png'), width = 4.5, height = 4)
#Heatmap de diferencias normalizadas
info <- data.frame(copemp = ec, UVemp = uj,
Memp = apply(matrizU, MARGIN = 1, M),
Wemp = apply(matrizU, MARGIN = 1, W))
H_melt <- data.frame(X1 = matrizU[,1], X2 = matrizU[,2],
value = apply(X = info, MARGIN = 1, FUN = D))
#Corregimos algunos valores
H_melt[is.infinite(H_melt$value), 3] <- sign(H_melt[is.infinite(H_melt$value), 3])*1
H_melt[is.na(H_melt$value), 3] <- 0
H_melt[abs(H_melt$value) > 1, 3] <- sign(H_melt[abs(H_melt$value) > 1, 3])*1
heat <- ggplot(H_melt, aes(X1, X2)) + geom_tile(aes(fill = value))  +
scale_x_reverse() +
scale_fill_gradientn(colours = hcl.colors(100, palette = "spectral", rev = TRUE),
limits = c(-1, 1)) + ylim(1, 0)
H <- heat + geom_point(data = X, aes(x = X[,1], y = X[nrow(X):1,2]),
color = "black", size = 1.5, alpha = 0.5) + scale_x_reverse() +
ggtitle(paste('Diferencias Normalizadas ', nombre))
ggsave(H, file = paste0(id, 'H', nombre, '.png'), width = 4.5, height = 4)
}
heatReg(5, Uhombres, h_selectH, 'Hom')
heats <- function(X, nombre, id, n = 100){
#Variables para sacar la copulas empirica
u <- seq(from = 0, to = 1, by = 1/(n-1))
n <- length(u)
#Matriz para hacer e grid
matrizU <- data.frame(u1 = rep(0, n**2), u2 = rep(0, n**2))
uj <- rep(0, n**2)
#Hacemos en Grid
cuenta <- 1
for (i in 1:n){
matrizU[cuenta:(i*n), 1] <- rep(u[i], n)
matrizU[cuenta:(i*n), 2] <- u
uj[cuenta:(i*n)] <- rep(u[i], n)*u
cuenta <- cuenta + n
}
matrizU <- as.matrix(matrizU)
#La copula empirica
ec <- C.n(matrizU, X = X)
#Hacemos las matrices
ecF <- matrix(ec, ncol = n, nrow = n)
UIJ <- matrix(uj, ncol = n, nrow = n)
# Los heatmaps
rho <- 12*(ecF - UIJ)
sigma <- 12*abs(ecF - UIJ)
breaksrho <- seq(-1, 1, by = 0.02)
breaksigma <- seq(0, 1, by = 0.01)
rho <- pheatmap(rho[nrow(rho):1,], breaks = breaksrho, border_color = NA,
cluster_cols = FALSE,
cluster_rows = FALSE, main = paste0('rho ', nombre))
ggsave(rho, file = paste0(id, 'rho', nombre, '.png'), width = 4.5, height = 4)
sigma <- pheatmap(sigma[nrow(sigma):1,], breaks = breaksigma, border_color = NA,
color = rev(paletteer_c("grDevices::PuBuGn", 200)),
cluster_cols = FALSE,
cluster_rows = FALSE, main = paste0('Sigma ', nombre))
ggsave(sigma, file = paste0(id, 'sigma', nombre, '.png'), width = 4.5, height = 4)
#Heatmap de diferencias normalizadas
info <- data.frame(copemp = ec, UVemp = uj,
Memp = apply(matrizU, MARGIN = 1, M),
Wemp = apply(matrizU, MARGIN = 1, W))
H_melt <- data.frame(X1 = matrizU[,1], X2 = matrizU[,2],
value = apply(X = info, MARGIN = 1, FUN = D))
#Corregimos algunos valores
H_melt[is.infinite(H_melt$value), 3] <- sign(H_melt[is.infinite(H_melt$value), 3])*1
H_melt[is.na(H_melt$value), 3] <- 0
H_melt[abs(H_melt$value) > 1, 3] <- sign(H_melt[abs(H_melt$value) > 1, 3])*1
heat <- ggplot(H_melt, aes(X1, X2)) + geom_tile(aes(fill = value))  +
scale_y_reverse() +
scale_fill_gradientn(colours = hcl.colors(100, palette = "spectral", rev = TRUE),
limits = c(-1, 1)) + ylim(1, 0)
H <- heat + geom_point(data = X, aes(x = X[,1], y = X[nrow(X):1,2]),
color = "black", size = 1.5, alpha = 0.5) + scale_y_reverse() +
ggtitle(paste('Diferencias Normalizadas ', nombre))
ggsave(H, file = paste0(id, 'H', nombre, '.png'), width = 4.5, height = 4)
}
heatReg(5, Uhombres, h_selectH, 'Hom')
heats <- function(X, nombre, id, n = 100){
#Variables para sacar la copulas empirica
u <- seq(from = 0, to = 1, by = 1/(n-1))
n <- length(u)
#Matriz para hacer e grid
matrizU <- data.frame(u1 = rep(0, n**2), u2 = rep(0, n**2))
uj <- rep(0, n**2)
#Hacemos en Grid
cuenta <- 1
for (i in 1:n){
matrizU[cuenta:(i*n), 1] <- rep(u[i], n)
matrizU[cuenta:(i*n), 2] <- u
uj[cuenta:(i*n)] <- rep(u[i], n)*u
cuenta <- cuenta + n
}
matrizU <- as.matrix(matrizU)
#La copula empirica
ec <- C.n(matrizU, X = X)
#Hacemos las matrices
ecF <- matrix(ec, ncol = n, nrow = n)
UIJ <- matrix(uj, ncol = n, nrow = n)
# Los heatmaps
rho <- 12*(ecF - UIJ)
sigma <- 12*abs(ecF - UIJ)
breaksrho <- seq(-1, 1, by = 0.02)
breaksigma <- seq(0, 1, by = 0.01)
rho <- pheatmap(rho[nrow(rho):1,], breaks = breaksrho, border_color = NA,
cluster_cols = FALSE,
cluster_rows = FALSE, main = paste0('rho ', nombre))
ggsave(rho, file = paste0(id, 'rho', nombre, '.png'), width = 4.5, height = 4)
sigma <- pheatmap(sigma[nrow(sigma):1,], breaks = breaksigma, border_color = NA,
color = rev(paletteer_c("grDevices::PuBuGn", 200)),
cluster_cols = FALSE,
cluster_rows = FALSE, main = paste0('Sigma ', nombre))
ggsave(sigma, file = paste0(id, 'sigma', nombre, '.png'), width = 4.5, height = 4)
#Heatmap de diferencias normalizadas
info <- data.frame(copemp = ec, UVemp = uj,
Memp = apply(matrizU, MARGIN = 1, M),
Wemp = apply(matrizU, MARGIN = 1, W))
H_melt <- data.frame(X1 = matrizU[,1], X2 = matrizU[,2],
value = apply(X = info, MARGIN = 1, FUN = D))
#Corregimos algunos valores
H_melt[is.infinite(H_melt$value), 3] <- sign(H_melt[is.infinite(H_melt$value), 3])*1
H_melt[is.na(H_melt$value), 3] <- 0
H_melt[abs(H_melt$value) > 1, 3] <- sign(H_melt[abs(H_melt$value) > 1, 3])*1
heat <- ggplot(H_melt, aes(X1, X2)) + geom_tile(aes(fill = value))  +
scale_y_reverse() +
scale_fill_gradientn(colours = hcl.colors(100, palette = "spectral", rev = TRUE),
limits = c(-1, 1)) + ylim(1, 0)
H <- heat + geom_point(data = X, aes(x = X[,1], y = X[nrow(X):1,2]),
color = "black", size = 1.5, alpha = 0.5) +
ggtitle(paste('Diferencias Normalizadas ', nombre))
ggsave(H, file = paste0(id, 'H', nombre, '.png'), width = 4.5, height = 4)
}
heatReg(5, Uhombres, h_selectH, 'Hom')
heats <- function(X, nombre, id, n = 100){
#Variables para sacar la copulas empirica
u <- seq(from = 0, to = 1, by = 1/(n-1))
n <- length(u)
#Matriz para hacer e grid
matrizU <- data.frame(u1 = rep(0, n**2), u2 = rep(0, n**2))
uj <- rep(0, n**2)
#Hacemos en Grid
cuenta <- 1
for (i in 1:n){
matrizU[cuenta:(i*n), 1] <- rep(u[i], n)
matrizU[cuenta:(i*n), 2] <- u
uj[cuenta:(i*n)] <- rep(u[i], n)*u
cuenta <- cuenta + n
}
matrizU <- as.matrix(matrizU)
#La copula empirica
ec <- C.n(matrizU, X = X)
#Hacemos las matrices
ecF <- matrix(ec, ncol = n, nrow = n)
UIJ <- matrix(uj, ncol = n, nrow = n)
# Los heatmaps
rho <- 12*(ecF - UIJ)
sigma <- 12*abs(ecF - UIJ)
breaksrho <- seq(-1, 1, by = 0.02)
breaksigma <- seq(0, 1, by = 0.01)
rho <- pheatmap(rho[nrow(rho):1,], breaks = breaksrho, border_color = NA,
cluster_cols = FALSE,
cluster_rows = FALSE, main = paste0('rho ', nombre))
ggsave(rho, file = paste0(id, 'rho', nombre, '.png'), width = 4.5, height = 4)
sigma <- pheatmap(sigma[nrow(sigma):1,], breaks = breaksigma, border_color = NA,
color = rev(paletteer_c("grDevices::PuBuGn", 200)),
cluster_cols = FALSE,
cluster_rows = FALSE, main = paste0('Sigma ', nombre))
ggsave(sigma, file = paste0(id, 'sigma', nombre, '.png'), width = 4.5, height = 4)
#Heatmap de diferencias normalizadas
info <- data.frame(copemp = ec, UVemp = uj,
Memp = apply(matrizU, MARGIN = 1, M),
Wemp = apply(matrizU, MARGIN = 1, W))
H_melt <- data.frame(X1 = matrizU[,1], X2 = matrizU[,2],
value = apply(X = info, MARGIN = 1, FUN = D))
#Corregimos algunos valores
H_melt[is.infinite(H_melt$value), 3] <- sign(H_melt[is.infinite(H_melt$value), 3])*1
H_melt[is.na(H_melt$value), 3] <- 0
H_melt[abs(H_melt$value) > 1, 3] <- sign(H_melt[abs(H_melt$value) > 1, 3])*1
heat <- ggplot(H_melt, aes(X1, X2)) + geom_tile(aes(fill = value))  +
scale_y_reverse() +
scale_fill_gradientn(colours = hcl.colors(100, palette = "spectral", rev = TRUE),
limits = c(-1, 1)) + ylim(1, 0)
H <- heat + geom_point(data = X, aes(x = X[,1], y = X[,2]),
color = "black", size = 1.5, alpha = 0.5) +
ggtitle(paste('Diferencias Normalizadas ', nombre))
ggsave(H, file = paste0(id, 'H', nombre, '.png'), width = 4.5, height = 4)
}
heatReg(5, Uhombres, h_selectH, 'Hom')
heats <- function(X, nombre, id, n = 100){
#Variables para sacar la copulas empirica
u <- seq(from = 0, to = 1, by = 1/(n-1))
n <- length(u)
#Matriz para hacer e grid
matrizU <- data.frame(u1 = rep(0, n**2), u2 = rep(0, n**2))
uj <- rep(0, n**2)
#Hacemos en Grid
cuenta <- 1
for (i in 1:n){
matrizU[cuenta:(i*n), 1] <- rep(u[i], n)
matrizU[cuenta:(i*n), 2] <- u
uj[cuenta:(i*n)] <- rep(u[i], n)*u
cuenta <- cuenta + n
}
matrizU <- as.matrix(matrizU)
#La copula empirica
ec <- C.n(matrizU, X = X)
#Hacemos las matrices
ecF <- matrix(ec, ncol = n, nrow = n)
UIJ <- matrix(uj, ncol = n, nrow = n)
# Los heatmaps
rho <- 12*(ecF - UIJ)
sigma <- 12*abs(ecF - UIJ)
breaksrho <- seq(-1, 1, by = 0.02)
breaksigma <- seq(0, 1, by = 0.01)
rho <- pheatmap(rho[nrow(rho):1,], breaks = breaksrho, border_color = NA,
cluster_cols = FALSE,
cluster_rows = FALSE, main = paste0('rho ', nombre))
ggsave(rho, file = paste0(id, 'rho', nombre, '.png'), width = 4.5, height = 4)
sigma <- pheatmap(sigma[nrow(sigma):1,], breaks = breaksigma, border_color = NA,
color = rev(paletteer_c("grDevices::PuBuGn", 200)),
cluster_cols = FALSE,
cluster_rows = FALSE, main = paste0('Sigma ', nombre))
ggsave(sigma, file = paste0(id, 'sigma', nombre, '.png'), width = 4.5, height = 4)
#Heatmap de diferencias normalizadas
info <- data.frame(copemp = ec, UVemp = uj,
Memp = apply(matrizU, MARGIN = 1, M),
Wemp = apply(matrizU, MARGIN = 1, W))
H_melt <- data.frame(X1 = matrizU[,1], X2 = matrizU[,2],
value = apply(X = info, MARGIN = 1, FUN = D))
#Corregimos algunos valores
H_melt[is.infinite(H_melt$value), 3] <- sign(H_melt[is.infinite(H_melt$value), 3])*1
H_melt[is.na(H_melt$value), 3] <- 0
H_melt[abs(H_melt$value) > 1, 3] <- sign(H_melt[abs(H_melt$value) > 1, 3])*1
heat <- ggplot(H_melt, aes(X1, X2)) + geom_tile(aes(fill = value))  +
scale_fill_gradientn(colours = hcl.colors(100, palette = "spectral", rev = TRUE),
limits = c(-1, 1)) + ylim(1, 0)
H <- heat + geom_point(data = X, aes(x = X[,1], y = X[,2]),
color = "black", size = 1.5, alpha = 0.5) +
ggtitle(paste('Diferencias Normalizadas ', nombre))
ggsave(H, file = paste0(id, 'H', nombre, '.png'), width = 4.5, height = 4)
}
heatReg(5, Uhombres, h_selectH, 'Hom')
heats <- function(X, nombre, id, n = 100){
#Variables para sacar la copulas empirica
u <- seq(from = 0, to = 1, by = 1/(n-1))
n <- length(u)
#Matriz para hacer e grid
matrizU <- data.frame(u1 = rep(0, n**2), u2 = rep(0, n**2))
uj <- rep(0, n**2)
#Hacemos en Grid
cuenta <- 1
for (i in 1:n){
matrizU[cuenta:(i*n), 1] <- rep(u[i], n)
matrizU[cuenta:(i*n), 2] <- u
uj[cuenta:(i*n)] <- rep(u[i], n)*u
cuenta <- cuenta + n
}
matrizU <- as.matrix(matrizU)
#La copula empirica
ec <- C.n(matrizU, X = X)
#Hacemos las matrices
ecF <- matrix(ec, ncol = n, nrow = n)
UIJ <- matrix(uj, ncol = n, nrow = n)
# Los heatmaps
rho <- 12*(ecF - UIJ)
sigma <- 12*abs(ecF - UIJ)
breaksrho <- seq(-1, 1, by = 0.02)
breaksigma <- seq(0, 1, by = 0.01)
rho <- pheatmap(rho[nrow(rho):1,], breaks = breaksrho, border_color = NA,
cluster_cols = FALSE,
cluster_rows = FALSE, main = paste0('rho ', nombre))
ggsave(rho, file = paste0(id, 'rho', nombre, '.png'), width = 4.5, height = 4)
sigma <- pheatmap(sigma[nrow(sigma):1,], breaks = breaksigma, border_color = NA,
color = rev(paletteer_c("grDevices::PuBuGn", 200)),
cluster_cols = FALSE,
cluster_rows = FALSE, main = paste0('Sigma ', nombre))
ggsave(sigma, file = paste0(id, 'sigma', nombre, '.png'), width = 4.5, height = 4)
#Heatmap de diferencias normalizadas
info <- data.frame(copemp = ec, UVemp = uj,
Memp = apply(matrizU, MARGIN = 1, M),
Wemp = apply(matrizU, MARGIN = 1, W))
H_melt <- data.frame(X1 = matrizU[,1], X2 = matrizU[,2],
value = apply(X = info, MARGIN = 1, FUN = D))
#Corregimos algunos valores
H_melt[is.infinite(H_melt$value), 3] <- sign(H_melt[is.infinite(H_melt$value), 3])*1
H_melt[is.na(H_melt$value), 3] <- 0
H_melt[abs(H_melt$value) > 1, 3] <- sign(H_melt[abs(H_melt$value) > 1, 3])*1
heat <- ggplot(H_melt, aes(X1, X2)) + geom_tile(aes(fill = value))  +
scale_fill_gradientn(colours = hcl.colors(100, palette = "spectral", rev = TRUE),
limits = c(-1, 1))
H <- heat + geom_point(data = X, aes(x = X[,1], y = X[,2]),
color = "black", size = 1.5, alpha = 0.5) +
ggtitle(paste('Diferencias Normalizadas ', nombre))
ggsave(H, file = paste0(id, 'H', nombre, '.png'), width = 4.5, height = 4)
}
heatReg(5, Uhombres, h_selectH, 'Hom')
heatReg(5, Umujeres, h_selectM, 'Muj')
heatReg(5, Utotal, h_selectT, 'Total')
cortes
cortes=0:(-2)
cortes
for (lev in 1:nrow(dataReg)){print(lev)}
dataReg
#deseadas. Recibe como argumentos:
#datos: un dataframe con los datos originales, (incluye la variable respuesta)
#variable: vector 2 dimensional, c(respuesta, efecto), la primer entrada
#   corresponde a la variable respuesta y la segunda la variable a la cual se
#   se le desea obtener los efectos.
#copulas: lista, contiene las copulas obtenidas del modelo
#alpha: vector de double, el nivel alpha con el cual se va a hacer
#       la regresión cuantil
#nombre: character, nombre con el caul se va guardar la imagen.
#Retorna un 1, si la función tiene éxito.
plot_effects <- function(datos, variable, copulas, alpha, nombre){
data <- data.frame(datos)
medias <- colMeans(datos)
#Se crea un data.frame auxilar con las medias de las otras variables
#que no son la respuesta y la desada
for (var in colnames(redMujeres)) {
if (!(var %in% variable)){
data[var] <- medias[var]
}
}
#Se hace la regresión pasra distintos niveles de alpha
datosAlphas <- data.frame(matrix(ncol = length(alpha), nrow = nrow(data)))
colnames(datosAlphas) <- as.character(alpha)
for (i in 1:length(alpha)){
datosAlphas[,i] <- regresionPred(datos, data, datos[,1], alpha[i], copulas)
}
datosAlphas$x <- datos[[variable[2]]]
#Se un pivote para poder graficar los efectos
dfgraf <- datosAlphas %>% pivot_longer(!x, names_to = "Alphas", values_to = "Pred")
#Se hace la grafica
graf <- ggplot(dfgraf, aes(x = x, y = Pred, colour = Alphas)) +
geom_point() +
geom_smooth(method = "lm", formula = y ~ splines::bs(x, 3), se = T) + #geom_smooth(se = FALSE) +
ylab('Q(a)') + xlab(paste0(variable[2])) + ggtitle('Grafica de Efectos')
ggsave(graf, file = paste0(nombre, '.png'), width = 4.5, height = 4)
return(1)
}
alleffect(redMujeres, y = 'FBIGC', copulas = copulas_selectM,
id = 'Muj', alphas = c(0.1, 0.5, 0.9))
#Función que hace la grafica de efectos de todas las variables de un modelo.
#Recide como parametros:
#datos: data.frame, con todos los datos originales del modelo (incluyendo la
#     la variable respuesta)
#y: vector o dataframe con la variable respuesta
#copula: lista que contiene todas las copulas ajustadas del modelo
#id: string, que contiene el identificador que se va a poner en el nombre
#   de la imagen cuando se guarde
#alphas: vector de double. Vector que contiene los niveles con los que
#       se va a hacer la regresión cuantil.
alleffect <- function(datos, y, copulas, id, alphas){
for (var in colnames(datos[-c(1)])){
plot_effects(datos, c(y, var), copulas,
alphas, paste0(id, var, 'Efec'))
}
}
alleffect(redMujeres, y = 'FBIGC', copulas = copulas_selectM,
id = 'Muj', alphas = c(0.1, 0.5, 0.9))
alleffect(redTotal, y = 'FBIGC', copulas = copulas_selectT,
id = 'Total', alphas = c(0.1, 0.5, 0.9))
alleffect(redHombres, y = 'FBIGC', copulas = copulas_selectH,
id = 'Hom', alphas = c(0.1, 0.5, 0.9))
#deseadas. Recibe como argumentos:
#datos: un dataframe con los datos originales, (incluye la variable respuesta)
#variable: vector 2 dimensional, c(respuesta, efecto), la primer entrada
#   corresponde a la variable respuesta y la segunda la variable a la cual se
#   se le desea obtener los efectos.
#copulas: lista, contiene las copulas obtenidas del modelo
#alpha: vector de double, el nivel alpha con el cual se va a hacer
#       la regresión cuantil
#nombre: character, nombre con el caul se va guardar la imagen.
#Retorna un 1, si la función tiene éxito.
plot_effects <- function(datos, variable, copulas, alpha, nombre){
data <- data.frame(datos)
medias <- colMeans(datos)
#Se crea un data.frame auxilar con las medias de las otras variables
#que no son la respuesta y la desada
for (var in colnames(redMujeres)) {
if (!(var %in% variable)){
data[var] <- medias[var]
}
}
#Se hace la regresión pasra distintos niveles de alpha
datosAlphas <- data.frame(matrix(ncol = length(alpha), nrow = nrow(data)))
colnames(datosAlphas) <- as.character(alpha)
for (i in 1:length(alpha)){
datosAlphas[,i] <- regresionPred(datos, data, datos[,1], alpha[i], copulas)
}
datosAlphas$x <- datos[[variable[2]]]
#Se un pivote para poder graficar los efectos
dfgraf <- datosAlphas %>% pivot_longer(!x, names_to = "Alphas", values_to = "Pred")
#Se hace la grafica
graf <- ggplot(dfgraf, aes(x = x, y = Pred, colour = Alphas)) +
geom_point() +
geom_smooth(method = "lm", formula = y ~ splines::bs(x, 3), se = FALSE) + #geom_smooth(se = FALSE) +
ylab('Q(a)') + xlab(paste0(variable[2])) + ggtitle('Grafica de Efectos')
ggsave(graf, file = paste0(nombre, '.png'), width = 4.5, height = 4)
return(1)
}
alleffect(redMujeres, y = 'FBIGC', copulas = copulas_selectM,
id = 'Muj', alphas = c(0.1, 0.5, 0.9))
alleffect(redHombres, y = 'FBIGC', copulas = copulas_selectH,
id = 'Hom', alphas = c(0.1, 0.5, 0.9))
alleffect(redTotal, y = 'FBIGC', copulas = copulas_selectT,
id = 'Total', alphas = c(0.1, 0.5, 0.9))
#deseadas. Recibe como argumentos:
#datos: un dataframe con los datos originales, (incluye la variable respuesta)
#variable: vector 2 dimensional, c(respuesta, efecto), la primer entrada
#   corresponde a la variable respuesta y la segunda la variable a la cual se
#   se le desea obtener los efectos.
#copulas: lista, contiene las copulas obtenidas del modelo
#alpha: vector de double, el nivel alpha con el cual se va a hacer
#       la regresión cuantil
#nombre: character, nombre con el caul se va guardar la imagen.
#Retorna un 1, si la función tiene éxito.
plot_effects <- function(datos, variable, copulas, alpha, nombre){
data <- data.frame(datos)
medias <- colMeans(datos)
#Se crea un data.frame auxilar con las medias de las otras variables
#que no son la respuesta y la desada
for (var in colnames(redMujeres)) {
if (!(var %in% variable)){
data[var] <- medias[var]
}
}
#Se hace la regresión pasra distintos niveles de alpha
datosAlphas <- data.frame(matrix(ncol = length(alpha), nrow = nrow(data)))
colnames(datosAlphas) <- as.character(alpha)
for (i in 1:length(alpha)){
datosAlphas[,i] <- regresionPred(datos, data, datos[,1], alpha[i], copulas)
}
datosAlphas$x <- datos[[variable[2]]]
#Se un pivote para poder graficar los efectos
dfgraf <- datosAlphas %>% pivot_longer(!x, names_to = "Alphas", values_to = "Pred")
#Se hace la grafica
graf <- ggplot(dfgraf, aes(x = x, y = Pred, colour = Alphas)) +
geom_point() +
geom_smooth(method = "lm", formula = y ~ splines::bs(x, 5), se = FALSE) + #geom_smooth(se = FALSE) +
ylab('Q(a)') + xlab(paste0(variable[2])) + ggtitle('Grafica de Efectos')
ggsave(graf, file = paste0(nombre, '.png'), width = 4.5, height = 4)
return(1)
}
alleffect(redTotal, y = 'FBIGC', copulas = copulas_selectT,
id = 'Total', alphas = c(0.1, 0.5, 0.9))
alleffect(redMujeres, y = 'FBIGC', copulas = copulas_selectM,
id = 'Muj', alphas = c(0.1, 0.5, 0.9))
alleffect(redHombres, y = 'FBIGC', copulas = copulas_selectH,
id = 'Hom', alphas = c(0.1, 0.5, 0.9))
